# Tennis Refactoring Kata

_Este proyecto es el resultado de aplicar t√©cnicas de Refactoring y Code Smell, el proyecto raiz que se utilizo como base dle ejerc√≠cio se puede encontrar en este [Repositorio](https://github.com/emilybache/Tennis-Refactoring-Kata) _

## Para Empezar üöÄ

_El proyecto propuesto otorga diferentes clases que permiten indagar en t√©cnicas de Refacotoring para tratar aplicar al mismo proyecto_t

# Tabla de Contenido <a name="indice"></a>
1. [Pre-Requisitos](#preRequisitos)
2. [Ejecuci√≥n de pruebas](#ejecucionPruebas)
3. [Analice las pruebas end-to-end](#analiceEndToEnd)
    1. [T√©cnicas Clase TennisGame1](#test1)
    2. [T√©cnicas Clase TennisGame2](#test2)
    3. [T√©cnicas Clase TennisGame3](#test3)
    4. [T√©cnicas Clase TennisGame4](#test4)
4. [Clean Code](#cleanCode)
    1. [C√≥digo enfocado](#codigoEnfocado)
    2. [Entendible](#entendible)
    3. [Escalable](#escalable)
    4. [Duplicidad](#duplicidad)
    5. [Testeable](#testeable)
    6. [Principio menor asombro](#principioMenorAsombro)
 5. [Testin Debt](#testinDeb)
    1. [Caracter√≠sticas](#caracteristicas)
    2. [Est√°ndares de nombramiento](#estandaresNombramiento)
    3. [Concejos](#concejos)
    4. [Malas pr√°cticas](#malasPracticas)
    5. [Pruebas faltantes](#pruebasFaltantes)
 6. [Better Code Hub](#betterCode)
    1. [Pasos](#pasos)
    2. [Resultados](#resultados)
    3. [Write short units of code](#writeShortUnitsOfCode)
    4. [Write Simple Units of code](#writeSimpleUnitsOfCode)
    5. [Write code once](#writeCodeOnce)
    6. [Keep unit interfaces small](#keepUnitInterfacesSmall)
    7. [Separate Concerns in modules](#separateConcernsModules)
    8. [Couple arquitecture components loosely](#coupleArquitecureComponentsLoosely)
    9. [Keep your codebase small](#keepYourCodebaseSmall)
    10. [Automate tests](#automateTest)
    11. [Write clean code](#writeCleanCode)


# Pre-Requisitos <a name="preRequisitos"></a> üìã

_El proyecto corre bajo la versi√≥n java 8 m√≠nimo para su compilaci√≥n_

[Tabla de Contenido](#indice)

## Ejecutando las pruebas <a name="ejecucionPruebas"></a> ‚öôÔ∏è

_El proyecto contiene una clase llamada TennisTest.java en donde se valida que su funcionamiento es el esperado_

La forma para correr la prueba unitaria se aconseja que sea por consola 

```
mvn test
```
[Tabla de Contenido](#indice)
## Analice las pruebas end-to-end <a name="analiceEndToEnd"></a> üî©

_La prueba hace uso de arrayList con la finalidad de generar diferentes posibles escenarios, una vez dimensionado los puntajes, se hace uso del polimorfismo ppor medio de una interfaz que generar patrones de comportamiento para las clases: TennisGame1, TennisGame2, TennisGame3 y TennisGame4_

```
public interface TennisGame {
    void wonPoint(String playerName);
    String getScore();
}
```
Esto se hace con cada clase
```
public class TennisGame1 implements TennisGame {
```

se hace uso de todas las clases de para hacer uso del m√©todo probatorio
```
public void checkAllScores(TennisGame game) {
        int highestScore = Math.max(this.player1Score, this.player2Score);
        for (int i = 0; i < highestScore; i++) {
            if (i < this.player1Score)
                game.wonPoint("player1");
            if (i < this.player2Score)
                game.wonPoint("player2");
        }
        assertEquals(this.expectedScore, game.getScore());
    }
    @Test
    public void checkAllScoresTennisGame1() {
        TennisGame1 game = new TennisGame1("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame2() {
        TennisGame2 game = new TennisGame2("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame3() {
        TennisGame3 game = new TennisGame3("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame4() {
        TennisGame game = new TennisGame4("player1", "player2");
        checkAllScores(game);
    }
```

## T√©cnicas Clase TennisGame1 <a name="test1"></a>‚å®Ô∏è
_Code smells_

Decompose Conditional en las l√≠neas 26 a 71

Replace Conditional with Polymorphism

Remove Assignments to Parameters


## T√©cnicas Clase TennisGame2 <a name="test2"></a>‚å®Ô∏è
_Code smells_

Consolidate Duplicate Conditional Fragments en las l√≠neas 18 a 99

Decompose Conditional en las l√≠neas 26 a 71

Replace Conditional with Polymorphism

Remove Assignments to Parameters

## T√©cnicas Clase TennisGame3 <a name="test3"></a>‚å®Ô∏è

_Code smells_

Extract Variable

## T√©cnicas Clase TennisGame4 <a name="test4"></a>‚å®Ô∏è

_Code smells_

Extract Variable

[Tabla de Contenido](#indice)

## Clean Code <a name="cleanCode"></a>üöÄ

_Caracter√≠sticas relacionadas en el c√≥digo para visualizar diferentes ejemplos en donde se muestra como tener un clean code_

### C√≥digo enfocado <a name="codigoEnfocado"></a>üìã

_El proyecto corre bajo la versi√≥n java 8 m√≠nimo para su compilaci√≥n_

```
 @Override
    public TennisResult getResult() {
        if (game.receiverHasWon())
            return new TennisResult("Win for " + game.receiver, "");
        return this.nextResult.getResult();
    }
}
class AdvantageServer implements ResultProvider {
    private final TennisGame4 game;
    private final ResultProvider nextResult;
    public AdvantageServer(TennisGame4 game, ResultProvider nextResult) {
        this.game = game;
        this.nextResult = nextResult;
    }
    @Override
    public TennisResult getResult() {
        if (game.serverHasAdvantage())
            return new TennisResult("Advantage " + game.server, "");
        return this.nextResult.getResult();
    }
```
Se puede visualizar m√©todos confusoso y que evitan tener un c√≥digo


## Entendible <a name="entendible"></a>‚öôÔ∏è

_Fragmentos del c√≥digo en donde no es entendible el inicio de variables por ejemplo _

```
    private int p2;
    private int p1;
    private String p1N;
    private String p2N;
    public TennisGame3(String p1N, String p2N) {
        this.p1N = p1N;
        this.p2N = p2N;
    }
```

### Escalable <a name="escalable"></a>üî©

_Debe ser escrito para el desarrollador y no para las maquinas_

```
 @java.lang.Override
    public String getScore() {
        TennisResult result = new Deuce(
                this, new GameServer(
                        this, new GameReceiver(
                                this, new AdvantageServer(
                                        this, new AdvantageReceiver(
                                                this, new DefaultResult(this)))))).getResult();
        return result.format();
    }
```
C√≥digo limpio y claro para futuros arreglos


## Duplicidad <a name="duplicidad"></a>‚å®Ô∏è
_Funciones en donde no queda claro poder establer su uso con solo su nombre o firma_
```
 class Deuce implements ResultProvider {
    private final TennisGame4 game;
    private final ResultProvider nextResult;
    public Deuce(TennisGame4 game, ResultProvider nextResult) {
        this.game = game;
        this.nextResult = nextResult;
    }
    
    class GameServer implements ResultProvider {
    private final TennisGame4 game;
    private final ResultProvider nextResult;
    public GameServer(TennisGame4 game, ResultProvider nextResult) {
        this.game = game;
        this.nextResult = nextResult;
    }
    @Override
    public TennisResult getResult() {
        if (game.serverHasWon())
            return new TennisResult("Win for " + game.server, "");
        return this.nextResult.getResult();
    }
}
    
    class GameReceiver implements ResultProvider {
    private final TennisGame4 game;
    private final ResultProvider nextResult;
    public GameReceiver(TennisGame4 game, ResultProvider nextResult) {
        this.game = game;
        this.nextResult = nextResult;
    }
    @Override
    public TennisResult getResult() {
        if (game.receiverHasWon())
            return new TennisResult("Win for " + game.receiver, "");
        return this.nextResult.getResult();
    }
}
```

### Testeable <a name="testeable"></a>‚å®Ô∏è
_Existe una prueba unitaria en donde se testea todas las clases_
```
@Test
    public void checkAllScoresTennisGame1() {
        TennisGame1 game = new TennisGame1("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame2() {
        TennisGame2 game = new TennisGame2("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame3() {
        TennisGame3 game = new TennisGame3("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame4() {
        TennisGame game = new TennisGame4("player1", "player2");
        checkAllScores(game);
    }
```

### Principio menor asombro <a name="principioMenorAsombro"></a>‚å®Ô∏è

Nombres claros y precisos para m√©todos
```
public void wonPoint(String playerName) {
  public String getScore() {
```
[Tabla de Contenido](#indice)

# Testin Debt <a name="testinDeb"></a>

Para establecer una afirmaci√≥n objetiva de c√≥digo de calidad en nuestro proyecto, es fundamental entender el concepto de deuda t√©cnica por Testing, estableciendo como base,
m√°s no √∫nica y ni aseverando que se haga de  forma completa, las pruebas unitarias. Siendo tan importante la claridad y calidad de nuestro c√≥digo, existen diferentes patrones 
para la creaci√≥n y seguimiento de nuestro c√≥digo, algunos de ellos relacionados con metodolog√≠as √°giles como se evidencia en esta [p√°gina](https://biblioteca.sistedes.es/wp-content/uploads/2016/08/CEDI_2016_paper_139.pdf)

Para este proyecto contamos con una clase de Test, que permite realizar y validar el comportamiento esperado de las diferentes clases utilizadas y 
dise√±adas en el proyecto. A continuaci√≥n se hara un an√°lisis de la intenci√≥n, calidad y relevancia de la prueba unitara.

## Caracter√≠sticas <a name="caracteristicas"></a>üìë

No existe una definici√≥n √∫nica que restrinja el dise√±o de las pruebas unitarias, sin embargo, existen unos principios aceptados de forma generalizada que establecen unos objetivos a cumplir al momento de pretender crear una prueba. Estos principios se conocen como F.I.R.ST. 

‚úîÔ∏è Fast: Su ciclo de vida debe ser corto, tiempo esperado no superior a 5 segundos.

‚úîÔ∏è Isolated: Su ciclo de vida no debe verse afectado por el funcionamiento o comportamiento de ninguna prueba externa o recurso.

‚úîÔ∏è Repeatable: Debe repetirse de manera indefinida y no verse afectado su comportamiento por eso.

‚úîÔ∏è Self Validation: Debe ser auto evaluable, esto quiere decir que la prueba misma representa el resultado y no genera ambig√ºedad para entenderlo, haciendo que sea false o true.

‚úîÔ∏è Timely: Va relacionado con el ciclo del proyecto, esta caracter√≠stica va relacionada con lo oportuno de la prueba, haciendo hincapi√© en la creaci√≥n de pruebas antes de salir a producci√≥n como valor m√≠nimo esperado.


## Est√°ndares de nombramiento <a name="estandaresNombramiento"></a>üìã

Las pruebas deben mantener un nombre que permita reconocer e identificar el metodo que se pretende probar, el estado a probar y comportamiento esperad.
En este proyecto encontramos la siguiente forma de nombramiento de los test.

```
  @Test
    public void checkAllScoresTennisGame1() {
        TennisGame1 game = new TennisGame1("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame2() {
        TennisGame2 game = new TennisGame2("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame3() {
        TennisGame3 game = new TennisGame3("player1", "player2");
        checkAllScores(game);
    }
    @Test
    public void checkAllScoresTennisGame4() {
        TennisGame game = new TennisGame4("player1", "player2");
        checkAllScores(game);
    }
```
Tenemos un nombre que no corresponde a ning√∫n m√©todo de la clase que pretende probar, tenemos un estado que se hace seguimiento y el nombre
de la clase a la que se le esta haciendo la prueba, pero no tenemor su valor esperado.


## Concejos <a name="concejos"></a>‚öôÔ∏è

_Aunque se tienen unos principios claves, estos son algunos concejos al momento de preocuparse por el dise√±o de pruebas unitarias _

‚úì Defina una estrategia adecuada de la pr√°ctica de testing
‚úì Utilice est√°ndares de nombramiento y pr√°cticas de CleanCodees sus UT
‚úì Escriba pruebas unitarias confiables
‚úì Convierta esta pr√°ctica como una regla
‚úì Divide y vencer√°s. Foco en un escenario a la vez
‚úì M√≠nimos Assertspor test 
‚úì No permitan que las pruebas tengan dependencias con servicios externos (Isolated) utilice Mocks
‚úì Son pruebas unitarias no deintegraci√≥n
‚úì Promover un cubrimiento alto (Coverage) hasta donde sea posible 
‚úì Las pruebas evolucionan a medida que el proyecto evoluciona
‚úì Nuevos defectos nuevas pruebas unitarias

## Malas pr√°cticas <a name="malasPracticas"></a>üî©

_Basado en la l√≥gica del proyecto, se identificaron los siguientes errores_

```
 public void checkAllScores(TennisGame game) {
        int highestScore = Math.max(this.player1Score, this.player2Score);
        for (int i = 0; i < highestScore; i++) {
            if (i < this.player1Score)
                game.wonPoint("player1");
            if (i < this.player2Score)
                game.wonPoint("player2");
        }
        assertEquals(this.expectedScore, game.getScore());
    }
```
A pesar de que existe un @Test para cada clase, se evidencia una constante en cada prueba que usa el m√©todo mostrado anteriormente, pese
a tener diferentes comportamientos l√≥gicos las clases. Se hace indispensable el dise√±o adecuado a probar por las diferentes clases
disea√±adas


## Pruebas faltantes <a name="pruebasFaltantes"></a>‚å®Ô∏è
_Se debe hacer prueba por los 2 m√©todos de la interfaz usada, evidenciandose a continuaci√≥n_
```
 public interface TennisGame {
    void wonPoint(String playerName);
    String getScore();
}
```
[Tabla de Contenido](#indice)

# Better Code Hub <a name="betterCode"></a>

Better Code Hub es un servicio de an√°lisis de c√≥digo fuente basado en la web que verifica el cumplimiento de una base de c√≥digo con las diez pautas presentadas en Creaci√≥n de software mantenible.

![Image text](https://miro.medium.com/max/1400/1*TS-ZTeI7sQS7dy_AlMqSXQ.png)

## Pasos <a name="pasos"></a>üìë
Pasos para la configuraci√≥n  y sincronizaci√≥n herramienta y proyecto

‚úîÔ∏è Crear una cuenta y sincronizar con la cuenta de git por medio de este [enlace](https://bettercodehub.com/).

‚úîÔ∏è Seleccionar el proyecto de la cuenta git para hacer una revisi√≥n del c√≥digo.

‚úîÔ∏è Analizar el resultado de la herramienta.

### Resultados <a name="resultados"></a>üìã

Encontramos diferentes t√≥picos arojados por el aplicativo.

‚úîÔ∏è Write short units of code.

‚úîÔ∏è Write simple units of code.

‚úîÔ∏è Write code once.

‚úîÔ∏è Keep unit interfaces small.

‚úîÔ∏è Separate concerns in modules.

‚úîÔ∏è Couple architecture components loosely.

‚úîÔ∏è Keep architecture components balanced.

‚úîÔ∏è Keep your codebase small.

‚úîÔ∏è Automate tests.

‚úîÔ∏è Write clean code.

## Write short units of code <a name="writeShortUnitsOfCode"></a>‚öôÔ∏è

_Las unidades son los grupos de c√≥digo m√°s peque√±os que se pueden mantener y ejecutar de forma independiente. En Java, las unidades son m√©todos o constructores. Una unidad siempre se ejecuta como un todo. No es posible invocar solo unas pocas l√≠neas de una unidad. Por lo tanto, la pieza de c√≥digo m√°s peque√±a que se puede reutilizar y probar es una unidad. _

Se identificaron 2 errores de unidades de c√≥digo
```
TennisGame2.getScore()        Lines of code / 78
TennisGame1.getScore()        Lines of code / 54
```
## Write Simple Units of code <a name="writeSimpleUnitsOfCode"></a>‚öôÔ∏è
La complejidad es una caracter√≠stica de calidad a menudo cuestionada. El c√≥digo que parece complejo para un desarrollador externo o novato puede parecer sencillo para un desarrollador que est√° √≠ntimamente familiarizado con √©l. En cierta medida, lo ‚Äúcomplejo‚Äù est√° en el ojo del espectador. Sin embargo, hay un punto en el que el c√≥digo se vuelve tan complejo que modificarlo se convierte en una tarea extremadamente arriesgada y que consume mucho tiempo, y mucho menos probar las modificaciones despu√©s. Para mantener el c√≥digo mantenible, debemos poner un l√≠mite a la complejidad. Otra raz√≥n para medir la complejidad es conocer el n√∫mero m√≠nimo de pruebas que necesitamos para estar suficientemente seguros de que el sistema act√∫a de forma predecible. Antes de que podamos definir un l√≠mite de complejidad de c√≥digo de este tipo, debemos poder medir la complejidad.

Una forma com√∫n de evaluar objetivamente la complejidad es contar el n√∫mero de rutas posibles a trav√©s de un fragmento de c√≥digo. La idea es que cuantos m√°s caminos se puedan distinguir, m√°s complejo ser√° un fragmento de c√≥digo. Podemos determinar el n√∫mero de caminos sin ambig√ºedades contando el n√∫mero de puntos de bifurcaci√≥n

```
TennisGame2.getScore()        Lines of code / 78  Branch points / 39
TennisGame1.getScore()        Lines of code / 54  Branch points / 15
TeniisGame3.getscore()        Lines of code / 13  Branch points / 7
```

## Write code once <a name="writeCodeOnce"></a>‚öôÔ∏è
_una filosof√≠a adoptada por un compilador y sus bibliotecas de software asociadas o por una biblioteca de software/ marco de software que se refiere a la capacidad de escribir un programa de computadora que se puede compilar en todas las plataformas sin necesidad de modificar su c√≥digo fuente_

```
Indicador pasado 
``` 
## Keep unit interfaces small <a name="keepUnitInterfacesSmall"></a> ‚öôÔ∏è

Hay muchas situaciones en la vida diaria de un programador donde las largas listas de par√°metros parecen inevitables. En el apuro de hacer las cosas, puede agregar algunos par√°metros m√°s a ese m√©todo para que funcione en casos excepcionales. Sin embargo, a largo plazo, esta forma de trabajar conducir√° a m√©todos dif√≠ciles de mantener y de reutilizar. Para mantener su c√≥digo mantenible, es esencial evitar largas listas de par√°metros o interfaces de unidades, limitando la cantidad de par√°metros que tienen


```
Indicador pasado 
``` 
## Separate Concerns in modules <a name="separateConcernsModules"></a>‚öôÔ∏è

Es un principio de dise√±o para separar un programa de computadora en distintas secciones. Cada secci√≥n aborda una preocupaci√≥n separada , un conjunto de informaci√≥n que afecta el c√≥digo de un programa de computadora. Una preocupaci√≥n puede ser tan general como "los detalles del hardware de una aplicaci√≥n" o tan espec√≠fica como "el nombre de la clase que se crear√°"

```
Indicador pasado 
``` 

## Couple arquitecture components loosely <a name="coupleArquitecureComponentsLoosely"></a>‚öôÔ∏è

Tener una visi√≥n clara de la arquitectura del software es esencial cuando crea y mantiene software. Una buena arquitectura de software le brinda una idea de lo que hace el sistema, c√≥mo lo hace y c√≥mo se organiza la funcionalidad (es decir, en agrupaciones de componentes). Le muestra la estructura de alto nivel, el "esqueleto", por as√≠ decirlo, del sistema. Tener una buena arquitectura hace que sea m√°s f√°cil encontrar el c√≥digo fuente que est√° buscando y comprender c√≥mo interact√∫an los componentes (de alto nivel) con otros componentes.

![image](https://user-images.githubusercontent.com/26014448/159193506-9cb1348d-4bff-434c-ad58-0770e198d070.png)
![image](https://user-images.githubusercontent.com/26014448/159193521-a3a2edb8-d79d-4709-a7c3-6cccc68fb8f7.png)

## Keep your codebase small <a name="keepYourCodebaseSmall"></a>‚öôÔ∏è
Una base de c√≥digo es una colecci√≥n de c√≥digo fuente que se almacena en un repositorio, se puede compilar e implementar de forma independiente y es mantenida por un equipo. Un sistema tiene al menos una base de c√≥digo. Los sistemas m√°s grandes a veces tienen m√°s de una base de c√≥digo. Un ejemplo t√≠pico es el software empaquetado. Puede haber una base de c√≥digo para la funcionalidad est√°ndar, y hay diferentes bases de c√≥digo mantenidas de forma independiente para complementos espec√≠ficos del cliente o del mercado.

![image](https://user-images.githubusercontent.com/26014448/159193580-2c6d23e6-5eb3-4c15-8ab3-ffb5c84e8b98.png)

## Automate tests <a name="automateTest"></a>‚öôÔ∏è

En las pruebas de software , la automatizaci√≥n de pruebas es el uso de software separado del software que se est√° probando para controlar la ejecuci√≥n de las pruebas y la comparaci√≥n de los resultados reales con los resultados previstos. [1] La automatizaci√≥n de pruebas puede automatizar algunas tareas repetitivas pero necesarias en un proceso de prueba formalizado que ya existe, o realizar pruebas adicionales que ser√≠an dif√≠ciles de realizar manualmente. La automatizaci√≥n de pruebas es fundamental para la entrega continua y las pruebas continuas

![image](https://user-images.githubusercontent.com/26014448/159193676-41d04c72-68f8-48a8-ad8f-fa6f693781e2.png)

## Write clean code <a name="writeCleanCode"></a>‚öôÔ∏è

Se considera que el c√≥digo es limpio (en ingl√©s, clean code) cuando es f√°cil de leer y entender. Si resuelve los problemas sin agregar complejidad innecesaria, permitiendo que el mantenimiento o las adaptaciones, por alg√∫n cambio de requerimiento, sean tareas m√°s sencillas, entonces estamos hablando de ‚Äúclean code‚Äù.

Para crear c√≥digo limpio hay que conocer y poner en pr√°ctica un conjunto de principios o t√©cnicas de desarrollo que nos ayudar√°n a evitar los code smells, es decir, esos s√≠ntomas de un programa que te dan el indicio de que existe un problema m√°s profundo.


```
Indicador pasado 
``` 
[Tabla de Contenido](#indice)


## Autores ‚úíÔ∏è

_Participantes_

* **Trabajo Base** - *Trabajo Inicial* - [David Castro](https://github.com/DavidCastro4444)

## Licencia üìÑ

Este proyecto est√° bajo la Licencia (Tu Licencia) - mira el archivo [LICENSE.md](LICENSE.md) para detalles

## Expresiones de Gratitud üéÅ

* Comenta a otros sobre este proyecto üì¢    
* Invita una cerveza üç∫ o un caf√© ‚òï a alguien del equipo. 
* Da las gracias p√∫blicamente ü§ì.
* etc.



---
‚å®Ô∏è con ‚ù§Ô∏è por [David Castro](https://github.com/DavidCastro4444) üòä
